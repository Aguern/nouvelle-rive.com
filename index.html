<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mariage Marine & Nicolas</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Karla:ital,wght@1,400&display=swap');

    body {
      font-family: 'Karla', sans-serif;
      background-color: #f7f7fc;
      color: #333;
      text-align: center;
      margin: 0;
      padding: 0;
    }

    .banner {
      width: 100vw;
      max-height: 300px;
      aspect-ratio: 16 / 9;
      object-fit: cover;
      object-position: center;
      display: block;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2rem;
      color: #333;
    }

    h2 {
      font-size: 1.2rem;
      color: #818edb;
      margin-top: 0.5rem;
    }

    p {
      margin: 1rem 0;
    }

    .btn-share-site {
      background-color: transparent;
      color: #818edb;
      border: 1px solid #818edb;
      padding: 0.8rem 1.5rem;
      border-radius: 25px;
      font-size: 0.9rem;
      cursor: pointer;
      margin: 1.5rem 0 2rem 0;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .btn-share-site:hover {
      background-color: #818edb;
      color: white;
    }

    .btn-share-site svg {
      width: 16px;
      height: 16px;
    }

    .btn-fixed {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #818edb;
      color: white;
      padding: 1rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: bold;
      border: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1000;
    }

    .btn-fixed:hover {
      background-color: #6f7ac7;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: white;
      padding: 2rem;
      border-radius: 20px;
      text-align: center;
      width: calc(90% - 2rem);
      max-width: 400px;
      margin: 1rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .modal-buttons {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .modal-buttons button {
      margin: 0;
      padding: 1.2rem 2rem;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.1rem;
      transition: all 0.2s;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .public-btn {
      background-color: #818edb;
      color: white;
    }

    .public-btn:hover {
      background-color: #6f7ac7;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(129, 142, 219, 0.4);
    }

    .private-btn {
      background-color: #f0f0f0;
      color: #333;
    }

    .private-btn:hover {
      background-color: #e0e0e0;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Loader */
    .loader {
      display: none;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #818edb;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 2rem auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #gallery {
      margin-top: 1.5rem;
    }

    /* Galerie √† marges fines et vignettes plein cadre */
    #drive-gallery {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      padding: 1rem 0;
      max-width: 900px;
      margin: auto;
    }

    #drive-gallery > div {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 100%;
      background: black;
      overflow: hidden;
    }

    #drive-gallery img,
    #drive-gallery video {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      cursor: pointer;
    }

    @media (min-width: 768px) {
      #drive-gallery {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    input[type='file'] {
      display: none;
    }

    .lightbox {
      display: none;
      position: fixed;
      z-index: 200;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .lightbox-content {
      max-width: 90%;
      max-height: 80vh;
    }

    .lightbox img,
    .lightbox video,
    .lightbox iframe {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 0;
    }

    /* Croix de fermeture */
    .lightbox .close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 2rem;
      color: white;
      line-height: 1;
      cursor: pointer;
      z-index: 1002;
    }

    /* Bouton t√©l√©chargement en haut √† gauche */
    .download-btn {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: none;
      border: none;
      z-index: 1001;
    }

    .download-btn img {
      width: 28px;
      height: 28px;
      filter: invert(1);
    }

    /* Navigation dans la lightbox */
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      font-size: 2.5rem;
      padding: 1rem 1.5rem;
      cursor: pointer;
      border-radius: 8px;
      transition: background-color 0.2s;
      z-index: 1001;
    }

    .lightbox-nav:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .lightbox-nav.prev {
      left: 1rem;
    }

    .lightbox-nav.next {
      right: 1rem;
    }

    body.lightbox-open .btn-fixed,
    body.modal-open .btn-fixed {
      display: none !important;
    }
  </style>
</head>
<body>

  <header>
    <img src="header.png" class="banner" alt="banni√®re"/>
  </header>

  <h1>Mariage Marine et Nicolas</h1>
  <h2>19 juillet 2025</h2>
  <p>N'h√©sitez pas √† nous partager vos photos ou vid√©os<br />afin de nous laisser un souvenir de cette journ√©e si sp√©ciale.</p>
  
  <button class="btn-share-site" onclick="shareSite()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
      <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
    </svg>
    Partager ce site
  </button>

  <button class="btn-fixed" onclick="openMediaSelector()">Partager mon souvenir</button>
  
  <!-- Input simplifi√© pour tous les appareils avec s√©lection multiple -->
  <input id="mediaInput" type="file" accept="image/*,video/*" multiple onchange="handleFiles(this.files)" />

  <div id="popup" class="modal">
    <div class="modal-content">
      <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Souhaitez-vous afficher ce m√©dia dans la galerie ?</p>
      <div class="loader" id="loader"></div>
      <div class="modal-buttons" id="modalButtons">
        <button class="public-btn" onclick="confirmUpload(true)">üì¢ Afficher en public</button>
        <button class="private-btn" onclick="confirmUpload(false)">üîí Uniquement pour les mari√©s</button>
      </div>
    </div>
  </div>

  <div id="gallery">
    <h2>Galerie des invit√©s</h2>
    <div id="drive-gallery"></div>
  </div>

  <div class="lightbox" id="lightbox" onclick="closeLightbox(event)">
    <div id="lightbox-content"></div>
    <button class="close-btn" onclick="closeLightbox({target:document.getElementById('lightbox')});">&times;</button>
    <button class="download-btn" id="downloadBtn" onclick="downloadMedia()">
      <img src="telecharger-un-fichier.png" alt="T√©l√©charger"/>
    </button>
    <button class="lightbox-nav prev" onclick="navigateGallery(-1)">‚Äπ</button>
    <button class="lightbox-nav next" onclick="navigateGallery(1)">‚Ä∫</button>
  </div>

  <script>
    /* --- CONFIG CLOUDINARY --- */
    const CLOUD_NAME      = 'dwnevq3ba';           
    const PRESET_PUBLIC   = 'public_gallery';
    const PRESET_PRIVATE  = 'private_uploads';
    const CLOUDINARY_URL  = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/upload`;
    /* ------------------------- */

    let galleryFiles = [];
    let currentImageIndex = 0;

    async function loadGallery() {
      // on appelle la function Vercel
      const files = await fetch('/api/gallery').then(r => r.json());

      // tri ant√©-chronologique (le plus r√©cent d'abord)
      files.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

      const container = document.getElementById('drive-gallery');
      galleryFiles = files; // pour la lightbox existante
      container.innerHTML = '';

      files.forEach((file, idx) => {
        const wrapper = document.createElement('div');
        const element = file.resource_type === 'video' 
          ? document.createElement('video')
          : document.createElement('img');

        element.src = file.secure_url;

        if (file.resource_type === 'video') {
          element.setAttribute('playsinline', '');
          element.setAttribute('muted', '');
          element.setAttribute('preload', 'metadata');
          element.setAttribute('poster', file.secure_url + '#t=0.1');
        }

        element.alt = file.public_id.split('/').pop();
        element.onclick = () => openLightbox(file.resource_type, file.secure_url, file.secure_url, idx);

        wrapper.appendChild(element);
        container.appendChild(wrapper);
      });
    }

    function openLightbox(type, src, downloadLink, index) {
      currentImageIndex = index;
      const content = document.getElementById("lightbox-content");
      const lightbox = document.getElementById("lightbox");
      const btn = document.getElementById("downloadBtn");

      content.innerHTML = "";

      if (type === 'video') {
        const vid = document.createElement('video');
        vid.src = src;
        vid.controls = true;
        vid.style.maxHeight = '80vh';
        content.appendChild(vid);
      } else {
        const img = document.createElement('img');
        img.src = src;
        content.appendChild(img);
      }

      btn.setAttribute("data-src", downloadLink);
      document.body.classList.add("lightbox-open");
      lightbox.style.display = "flex";
      
      updateNavigationButtons();
    }

    function navigateGallery(direction) {
      currentImageIndex += direction;
      
      if (currentImageIndex < 0) currentImageIndex = galleryFiles.length - 1;
      if (currentImageIndex >= galleryFiles.length) currentImageIndex = 0;
      
      const file = galleryFiles[currentImageIndex];
      const src = file.secure_url;
      
      openLightbox(file.resource_type, src, file.secure_url, currentImageIndex);
    }

    function updateNavigationButtons() {
      const prevBtn = document.querySelector('.lightbox-nav.prev');
      const nextBtn = document.querySelector('.lightbox-nav.next');
      
      prevBtn.style.display = galleryFiles.length > 1 ? 'block' : 'none';
      nextBtn.style.display = galleryFiles.length > 1 ? 'block' : 'none';
    }

    function downloadMedia() {
      const src = document.getElementById("downloadBtn").getAttribute("data-src");
      
      // Cr√©er un lien de t√©l√©chargement et le d√©clencher
      const a = document.createElement("a");
      a.href = src;
      a.download = galleryFiles[currentImageIndex].public_id.split('/').pop() || "media";
      a.target = "_blank";
      
      // Ajouter temporairement le lien au DOM
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    function closeLightbox(event) {
      if (event.target.id === "lightbox" || event.key === "Escape" || event.target.classList.contains('close-btn')) {
        document.getElementById("lightbox").style.display = "none";
        document.body.classList.remove("lightbox-open");
      }
    }

    document.addEventListener("keydown", closeLightbox);
    window.addEventListener("DOMContentLoaded", loadGallery);

    // Fonction simplifi√©e pour ouvrir le s√©lecteur de m√©dia
    function openMediaSelector() {
      // Ouvrir directement l'input sur tous les appareils
      document.getElementById('mediaInput').click();
    }

    // Fonction de partage du site
    async function shareSite() {
      const shareData = {
        title: 'Mariage Marine & Nicolas',
        text: 'Venez partager vos souvenirs du mariage de Marine & Nicolas ! üì∏üíï',
        url: window.location.href
      };

      try {
        // V√©rifier si l'API Web Share est support√©e
        if (navigator.share) {
          await navigator.share(shareData);
        } else {
          // Fallback : copier le lien et afficher un message
          await navigator.clipboard.writeText(window.location.href);
          alert('Lien copi√© dans le presse-papiers !\n\nVous pouvez maintenant le partager via WhatsApp, SMS ou email.');
        }
      } catch (err) {
        // En cas d'erreur ou d'annulation, proposer la copie du lien
        if (err.name !== 'AbortError') {
          try {
            await navigator.clipboard.writeText(window.location.href);
            alert('Lien copi√© dans le presse-papiers !');
          } catch (clipboardErr) {
            // Fallback ultime si m√™me le clipboard ne fonctionne pas
            prompt('Copiez ce lien pour le partager :', window.location.href);
          }
        }
      }
    }

    let selectedFiles = [];
    
    // Fonction pour g√©rer la s√©lection multiple avec aper√ßu + VALIDATION PAR TAILLE TOTALE
    function handleFiles(files) {
      if (files && files.length > 0) {
        const validFiles = [];
        const invalidFiles = [];
        let totalSizeMB = 0;
        
        // Premi√®re passe : validation individuelle
        Array.from(files).forEach(file => {
          const isVideo = file.type.includes('video');
          const maxSize = isVideo ? MAX_VIDEO_SIZE_MB : MAX_FILE_SIZE_MB;
          const fileSizeMB = file.size / (1024 * 1024);
          
          if (fileSizeMB > maxSize) {
            invalidFiles.push({
              name: file.name,
              size: fileSizeMB.toFixed(1),
              maxSize: maxSize,
              type: isVideo ? 'vid√©o' : 'photo',
              reason: 'trop_gros'
            });
          } else {
            validFiles.push(file);
            totalSizeMB += fileSizeMB;
          }
        });
        
        // Deuxi√®me passe : v√©rification de la taille totale
        if (totalSizeMB > MAX_TOTAL_SIZE_MB) {
          // Trier par taille pour prendre les plus petits d'abord
          validFiles.sort((a, b) => a.size - b.size);
          
          const acceptedFiles = [];
          let runningTotal = 0;
          
          for (const file of validFiles) {
            const fileSizeMB = file.size / (1024 * 1024);
            if (runningTotal + fileSizeMB <= MAX_TOTAL_SIZE_MB) {
              acceptedFiles.push(file);
              runningTotal += fileSizeMB;
            } else {
              invalidFiles.push({
                name: file.name,
                size: fileSizeMB.toFixed(1),
                maxSize: MAX_TOTAL_SIZE_MB,
                type: file.type.includes('video') ? 'vid√©o' : 'photo',
                reason: 'quota_depass√©'
              });
            }
          }
          
          validFiles.length = 0;
          validFiles.push(...acceptedFiles);
          totalSizeMB = runningTotal;
        }
        
        // Afficher les erreurs si n√©cessaire
        if (invalidFiles.length > 0) {
          let errorMessage = '';
          const tooLargeFiles = invalidFiles.filter(f => f.reason === 'trop_gros');
          const quotaFiles = invalidFiles.filter(f => f.reason === 'quota_depass√©');
          
          if (tooLargeFiles.length > 0) {
            errorMessage += 'Fichiers trop volumineux :\n';
            tooLargeFiles.forEach(file => {
              errorMessage += `‚Ä¢ ${file.name} (${file.size}MB) - Max ${file.maxSize}MB\n`;
            });
            errorMessage += '\n';
          }
          
          if (quotaFiles.length > 0) {
            errorMessage += `Quota de ${MAX_TOTAL_SIZE_MB}MB d√©pass√©, fichiers exclus :\n`;
            quotaFiles.forEach(file => {
              errorMessage += `‚Ä¢ ${file.name} (${file.size}MB)\n`;
            });
            errorMessage += '\n';
          }
          
          if (validFiles.length > 0) {
            errorMessage += `${validFiles.length} fichier(s) s√©lectionn√©(s) (${totalSizeMB.toFixed(1)}MB au total)`;
          } else {
            errorMessage += 'Aucun fichier valide. Essayez avec des fichiers plus petits.';
          }
          
          showDiscretError(errorMessage, 8000);
        }
        
        // Continuer avec les fichiers valides
        if (validFiles.length > 0) {
          selectedFiles = validFiles;
          showFilePreview(selectedFiles, totalSizeMB);
        }
      }
    }
    
    // Fonction pour afficher l'aper√ßu des fichiers s√©lectionn√©s + TAILLE TOTALE
    function showFilePreview(files, totalSizeMB) {
      const modalContent = document.querySelector('.modal-content');
      const fileCount = files.length;
      
      // G√©n√©rer l'aper√ßu des fichiers avec tailles
      let filePreviewHtml = '';
      files.forEach((file, index) => {
        const fileType = file.type.includes('video') ? 'üé•' : 'üì∑';
        const fileName = file.name.length > 20 ? file.name.substring(0, 20) + '...' : file.name;
        const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
        filePreviewHtml += `
          <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem; margin: 0.25rem 0; background: #f8f9fa; border-radius: 8px;">
            <div style="display: flex; align-items: center;">
              <span style="font-size: 1.2rem; margin-right: 0.5rem;">${fileType}</span>
              <span style="font-size: 0.9rem; color: #666;">${fileName}</span>
            </div>
            <span style="font-size: 0.8rem; color: #999; font-weight: bold;">${fileSizeMB}MB</span>
          </div>
        `;
      });
      
      // Texte adapt√© au nombre de fichiers
      const fileTypes = files.map(f => f.type.includes('video') ? 'vid√©o' : 'photo');
      const hasVideos = fileTypes.includes('vid√©o');
      const hasPhotos = fileTypes.includes('photo');
      
      let typeText = '';
      if (hasVideos && hasPhotos) {
        typeText = `${fileCount} m√©dias`;
      } else if (hasVideos) {
        typeText = fileCount === 1 ? '1 vid√©o' : `${fileCount} vid√©os`;
      } else {
        typeText = fileCount === 1 ? '1 photo' : `${fileCount} photos`;
      }
      
      modalContent.innerHTML = `
        <div style="padding: 1.5rem;">
          <h3 style="margin-bottom: 1rem; color: #333;">Partager ${typeText}</h3>
          <div style="background: #e8f4fd; padding: 0.8rem; border-radius: 8px; margin-bottom: 1rem;">
            <div style="font-weight: bold; color: #2196F3;">üìä Taille totale : ${totalSizeMB.toFixed(1)}MB / ${MAX_TOTAL_SIZE_MB}MB</div>
            <div style="font-size: 0.8rem; color: #666; margin-top: 0.2rem;">${fileCount} fichier(s) s√©lectionn√©(s)</div>
          </div>
          <div style="max-height: 200px; overflow-y: auto; margin-bottom: 1.5rem;">
            ${filePreviewHtml}
          </div>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1.5rem;">
            O√π souhaitez-vous partager ${fileCount === 1 ? 'ce fichier' : 'ces fichiers'} ?
          </p>
          <div style="display: flex; flex-direction: column; gap: 1rem;">
            <button onclick="confirmUpload(true)" style="
              background-color: #818edb; color: white; border: none; padding: 1rem 1.5rem; 
              border-radius: 12px; font-weight: bold; cursor: pointer; font-size: 1rem;
              transition: all 0.2s;
            " onmouseover="this.style.backgroundColor='#6f7ac7'" onmouseout="this.style.backgroundColor='#818edb'">
              üì¢ Galerie publique
            </button>
            <button onclick="confirmUpload(false)" style="
              background-color: #f0f0f0; color: #333; border: none; padding: 1rem 1.5rem; 
              border-radius: 12px; font-weight: bold; cursor: pointer; font-size: 1rem;
              transition: all 0.2s;
            " onmouseover="this.style.backgroundColor='#e0e0e0'" onmouseout="this.style.backgroundColor='#f0f0f0'">
              üîí Uniquement pour les mari√©s
            </button>
            <button onclick="cancelUpload()" style="
              background-color: transparent; color: #999; border: 1px solid #ddd; padding: 0.8rem 1.5rem; 
              border-radius: 12px; cursor: pointer; font-size: 0.9rem;
            " onmouseover="this.style.borderColor='#bbb'" onmouseout="this.style.borderColor='#ddd'">
              Annuler
            </button>
          </div>
        </div>
      `;
      
      // Afficher la modal
      document.getElementById('popup').style.display = 'flex';
      document.body.classList.add('modal-open'); // Masquer le bouton fixe
    }
    
    // Fonction pour confirmer l'upload - VALIDATION PAR TAILLE TOTALE
    function confirmUpload(isPublic) {
      // Plus de limite sur le nombre, juste v√©rification de la taille totale
      const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
      const totalSizeMB = totalSize / (1024 * 1024);
      
      if (totalSizeMB > MAX_TOTAL_SIZE_MB) {
        showDiscretError(`Taille totale trop importante : ${totalSizeMB.toFixed(1)}MB / ${MAX_TOTAL_SIZE_MB}MB max.`);
        return;
      }
      
      const modalContent = document.querySelector('.modal-content');
      const fileCount = selectedFiles.length;
      const destination = isPublic ? 'galerie publique' : 'galerie priv√©e';
      
      // Feedback imm√©diat de succ√®s (SEULEMENT si <= 10 fichiers)
      modalContent.innerHTML = `
        <div style="padding: 2rem;">
          <div style="font-size: 3rem; margin-bottom: 1rem;">üéâ</div>
          <h3 style="color: #4CAF50; margin-bottom: 1rem;">Merci !</h3>
          <p style="font-size: 1.1rem;">
            ${fileCount === 1 ? 'Votre fichier a √©t√© envoy√©' : `Vos ${fileCount} fichiers ont √©t√© envoy√©s`} vers ${destination} ! 
          </p>
          <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
            ${isPublic ? 'Il appara√Ætra dans la galerie dans quelques instants.' : 'Les mari√©s le recevront directement.'}
          </p>
        </div>
      `;
      
      // Fermer automatiquement apr√®s 3 secondes
      setTimeout(() => {
        document.getElementById('popup').style.display = 'none';
        document.body.classList.remove('modal-open'); // R√©afficher le bouton fixe
        resetModal();
      }, 3000);
      
      // Upload en arri√®re-plan
      uploadMultipleFilesInBackground(selectedFiles, isPublic);
      
      // D√©marrer le suivi de progression
      setTimeout(showUploadProgress, 2000);
      
      // R√©initialiser la s√©lection
      selectedFiles = [];
      document.getElementById('mediaInput').value = '';
    }
    
    // Fonction pour annuler l'upload
    function cancelUpload() {
      document.getElementById('popup').style.display = 'none';
      document.body.classList.remove('modal-open'); // R√©afficher le bouton fixe
      resetModal();
      
      // R√©initialiser la s√©lection
      selectedFiles = [];
      document.getElementById('mediaInput').value = '';
    }
    
    // Fonction pour r√©initialiser la modal
    function resetModal() {
      const modalContent = document.querySelector('.modal-content');
      modalContent.innerHTML = `
        <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Souhaitez-vous afficher ce m√©dia dans la galerie ?</p>
        <div class="loader" id="loader"></div>
        <div class="modal-buttons" id="modalButtons">
          <button class="public-btn" onclick="confirmUpload(true)">üì¢ Afficher en public</button>
          <button class="private-btn" onclick="confirmUpload(false)">üîí Uniquement pour les mari√©s</button>
        </div>
      `;
    }
    
    // Fonction de compatibilit√© pour l'upload simple
    function handleFile(file) {
      if (file) {
        handleFiles([file]);
      }
    }

    // Variables pour la gestion de la charge - BAS√âES SUR LA TAILLE TOTALE
    let uploadQueue = [];
    let activeUploads = 0;
    let isUploading = false; // Flag pour tracker l'√©tat d'upload
    const MAX_CONCURRENT_UPLOADS = 5; // 5 uploads simultan√©s
    const MAX_RETRY_ATTEMPTS = 2;
    const MAX_FILE_SIZE_MB = 25; // 25MB par fichier individuel
    const MAX_VIDEO_SIZE_MB = 80; // 80MB par vid√©o individuelle
    const MAX_TOTAL_SIZE_MB = 150; // 150MB au total par batch (limite intelligente)

    // Fonction pour uploader plusieurs fichiers avec gestion de charge am√©lior√©e + PROTECTION
    async function uploadMultipleFilesInBackground(files, isPublic) {
      console.log(`üöÄ Ajout de ${files.length} fichier(s) √† la queue d'upload`);
      
      // Marquer le d√©but de l'upload
      isUploading = true;
      updateUploadUI();
      
      // Ajouter les fichiers √† la queue
      files.forEach(file => {
        uploadQueue.push({
          file: file,
          isPublic: isPublic,
          attempts: 0,
          id: Date.now() + Math.random() // ID unique
        });
      });
      
      // D√©marrer le traitement de la queue
      processUploadQueue();
    }
    
    // Fonction pour traiter la queue d'upload - OPTIMIS√âE POUR 30 INVIT√âS + PROTECTION
    async function processUploadQueue() {
      while (uploadQueue.length > 0 && activeUploads < MAX_CONCURRENT_UPLOADS) {
        const uploadTask = uploadQueue.shift();
        if (uploadTask) {
          activeUploads++;
          updateUploadUI();
          
          uploadFileWithRetry(uploadTask).finally(() => {
            activeUploads--;
            updateUploadUI();
            
            // Continuer le traitement de la queue plus rapidement
            if (uploadQueue.length > 0) {
              setTimeout(() => processUploadQueue(), 100); // R√©duit √† 100ms
            } else if (activeUploads === 0) {
              // Tous les uploads termin√©s
              console.log('‚úÖ Tous les uploads termin√©s');
              isUploading = false;
              updateUploadUI();
              setTimeout(() => loadGallery(), 1500);
            }
          });
        }
      }
    }
    
    // Fonction d'upload avec retry automatique
    async function uploadFileWithRetry(uploadTask) {
      const { file, isPublic, attempts, id } = uploadTask;
      
      try {
        console.log(`üì§ Upload ${file.name} (tentative ${attempts + 1}/${MAX_RETRY_ATTEMPTS})`);
        await uploadSingleFileInBackground(file, isPublic);
        console.log(`‚úÖ Upload r√©ussi: ${file.name}`);
        
      } catch (error) {
        console.error(`‚ùå √âchec upload ${file.name}:`, error);
        
        // Retry automatique si pas trop de tentatives
        if (attempts < MAX_RETRY_ATTEMPTS - 1) {
          console.log(`üîÑ Retry ${file.name} dans 2 secondes...`);
          uploadTask.attempts++;
          
          // Remettre en queue avec d√©lai
          setTimeout(() => {
            uploadQueue.unshift(uploadTask); // Priorit√© aux retry
            processUploadQueue();
          }, 2000 + (attempts * 1000)); // D√©lai croissant
          
        } else {
          // √âchec d√©finitif apr√®s tous les retry
          showDiscretError(`√âchec d√©finitif: ${file.name}`);
        }
      }
    }
    
    // ‚Äî VERSION CLOUDINARY OPTIMIS√âE POUR GROS VOLUMES ‚Äî
    async function uploadSingleFileInBackground(file, isPublic) {
      // Compression l√©g√®re seulement pour les tr√®s gros fichiers
      const processedFile = await compressFileIfNeeded(file);
      
      const data = new FormData();
      data.append('file', processedFile);
      data.append('upload_preset', isPublic ? PRESET_PUBLIC : PRESET_PRIVATE);
      if (isPublic) data.append('tags', PRESET_PUBLIC);
      
      // Optimisations Cloudinary pour performance, pas √©conomie
      data.append('quality', 'auto:best'); // Meilleure qualit√©
      data.append('fetch_format', 'auto'); // Format optimal
      
      const ctrl = new AbortController();
      // timeout 5 min pour les tr√®s gros fichiers
      const timeout = setTimeout(() => ctrl.abort(), 300000);
      
      const res = await fetch(CLOUDINARY_URL, {
        method: 'POST',
        body: data,
        signal: ctrl.signal
      }).catch(err => {
        throw new Error('Timeout / r√©seau');
      });
      
      clearTimeout(timeout);
      
      const json = await res.json();
      if (!res.ok) throw new Error(json.error?.message || 'Upload √©chou√©');
      
      return json;
    }
    
    // Compression tr√®s l√©g√®re seulement pour les fichiers √©normes
    async function compressFileIfNeeded(file) {
      // Seulement pour les images > 20MB, compression l√©g√®re
      if (file.type.includes('image') && file.size > 20 * 1024 * 1024) {
        return new Promise((resolve) => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();
          
          img.onload = () => {
            // Redimensionner seulement si > 4000px (tr√®s haute r√©solution)
            const maxWidth = 4000;
            const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
            
            if (ratio < 1) {
              canvas.width = img.width * ratio;
              canvas.height = img.height * ratio;
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              
              canvas.toBlob((blob) => {
                const compressedFile = new File([blob], file.name, {
                  type: file.type,
                  lastModified: file.lastModified
                });
                resolve(compressedFile);
              }, file.type, 0.9); // 90% de qualit√©
            } else {
              resolve(file);
            }
          };
          
          img.onerror = () => resolve(file);
          img.src = URL.createObjectURL(file);
        });
      }
      
      return file; // Pas de compression pour la plupart des fichiers
    }

    // Fonction pour afficher une erreur discr√®te - AM√âLIOR√âE
    function showDiscretError(message, duration = 4000) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #f44336;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 25px;
        font-size: 0.9rem;
        z-index: 1001;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        opacity: 0;
        transition: opacity 0.3s ease;
        max-width: 90%;
        white-space: pre-line;
        text-align: center;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      // Animation d'apparition
      setTimeout(() => notification.style.opacity = '1', 100);
      
      // Supprimer apr√®s dur√©e sp√©cifi√©e
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
          if (notification.parentNode) {
            document.body.removeChild(notification);
          }
        }, 300);
      }, duration);
    }

    async function sendMedia(isPublic) {
      // Cette fonction n'est plus utilis√©e car le feedback est imm√©diat dans handleFiles()
      console.log('sendMedia appel√©e, mais upload d√©j√† fait en arri√®re-plan');
    }

    // Fonction de compatibilit√© pour l'upload simple
    async function uploadFileInBackground(file, isPublic) {
      return uploadSingleFileInBackground(file, isPublic);
    }
    
    // PROTECTION CONTRE LE RECHARGEMENT DE PAGE
    function updateUploadUI() {
      const btn = document.querySelector('.btn-fixed');
      
      if (isUploading) {
        const remaining = uploadQueue.length + activeUploads;
        // Texte plus compact pour √©viter le retour √† la ligne
        btn.innerHTML = `üì§ Upload en cours<br><small>(${remaining} restant${remaining > 1 ? 's' : ''})</small>`;
        btn.style.backgroundColor = '#ff9800'; // Orange pendant upload
        btn.style.lineHeight = '1.2'; // R√©duire l'espacement des lignes
        
        // D√©sactiver le bouton de s√©lection de fichiers
        btn.onclick = () => {
          showDiscretError('Upload en cours... Veuillez patienter avant d\'ajouter d\'autres fichiers.');
        };
      } else {
        btn.innerHTML = 'Partager mon souvenir';
        btn.style.backgroundColor = '#818edb'; // Couleur normale
        btn.style.lineHeight = ''; // R√©initialiser
        btn.onclick = openMediaSelector; // R√©activer
      }
    }
    
    // Protection contre le rechargement de page
    window.addEventListener('beforeunload', (event) => {
      if (isUploading && (uploadQueue.length > 0 || activeUploads > 0)) {
        const message = 'Upload en cours ! Si vous quittez maintenant, vos fichiers ne seront pas envoy√©s.';
        event.preventDefault();
        event.returnValue = message; // Chrome
        return message; // Firefox
      }
    });
    
    // Protection contre la fermeture de l'onglet
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isUploading) {
        console.warn('‚ö†Ô∏è Page masqu√©e pendant l\'upload - les uploads peuvent √™tre interrompus');
      }
    });
    
    // Notification persistante pendant l'upload
    function showUploadProgress() {
      if (!isUploading) return;
      
      const remaining = uploadQueue.length + activeUploads;
      if (remaining > 0) {
        console.log(`üì§ Upload en cours: ${remaining} fichier(s) restant(s)`);
        setTimeout(showUploadProgress, 5000); // Rappel toutes les 5 secondes
      }
    }
  </script>

</body>
</html>
