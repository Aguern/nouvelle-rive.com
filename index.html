<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mariage Marine & Nicolas</title>
  <script src="https://apis.google.com/js/api.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Karla:ital,wght@1,400&display=swap');

    body {
      font-family: 'Karla', sans-serif;
      background-color: #f7f7fc;
      color: #333;
      text-align: center;
      margin: 0;
      padding: 0;
    }

    .banner {
      width: 100vw;
      max-height: 300px;
      aspect-ratio: 16 / 9;
      object-fit: cover;
      object-position: center;
      display: block;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2rem;
      color: #333;
    }

    h2 {
      font-size: 1.2rem;
      color: #818edb;
      margin-top: 0.5rem;
    }

    p {
      margin: 1rem 0;
    }

    .btn-share-site {
      background-color: transparent;
      color: #818edb;
      border: 1px solid #818edb;
      padding: 0.8rem 1.5rem;
      border-radius: 25px;
      font-size: 0.9rem;
      cursor: pointer;
      margin: 1.5rem 0 2rem 0;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.3s ease;
    }

    .btn-share-site:hover {
      background-color: #818edb;
      color: white;
    }

    .btn-share-site svg {
      width: 16px;
      height: 16px;
    }

    .btn-fixed {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #818edb;
      color: white;
      padding: 1rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: bold;
      border: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1000;
    }

    .btn-fixed:hover {
      background-color: #6f7ac7;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: white;
      padding: 2rem;
      border-radius: 20px;
      text-align: center;
      width: calc(90% - 2rem);
      max-width: 400px;
      margin: 1rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .modal-buttons {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .modal-buttons button {
      margin: 0;
      padding: 1.2rem 2rem;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.1rem;
      transition: all 0.2s;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .public-btn {
      background-color: #818edb;
      color: white;
    }

    .public-btn:hover {
      background-color: #6f7ac7;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(129, 142, 219, 0.4);
    }

    .private-btn {
      background-color: #f0f0f0;
      color: #333;
    }

    .private-btn:hover {
      background-color: #e0e0e0;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Loader */
    .loader {
      display: none;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #818edb;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 2rem auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #gallery {
      margin-top: 3rem;
    }

    /* Galerie √† marges fines et vignettes plein cadre */
    #drive-gallery {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      padding: 1rem 0;
      max-width: 900px;
      margin: auto;
    }

    #drive-gallery > div {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 100%;
      background: black;
      overflow: hidden;
    }

    #drive-gallery img,
    #drive-gallery video {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      cursor: pointer;
    }

    @media (min-width: 768px) {
      #drive-gallery {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    input[type='file'] {
      display: none;
    }

    .lightbox {
      display: none;
      position: fixed;
      z-index: 200;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .lightbox-content {
      max-width: 90%;
      max-height: 80vh;
    }

    .lightbox img,
    .lightbox video,
    .lightbox iframe {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 12px;
    }

    /* Croix de fermeture */
    .lightbox .close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 2rem;
      color: white;
      line-height: 1;
      cursor: pointer;
      z-index: 1002;
    }

    /* Bouton t√©l√©chargement en haut √† gauche */
    .download-btn {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: none;
      border: none;
      z-index: 1001;
    }

    .download-btn img {
      width: 28px;
      height: 28px;
      filter: invert(1);
    }

    /* Navigation dans la lightbox */
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      font-size: 2.5rem;
      padding: 1rem 1.5rem;
      cursor: pointer;
      border-radius: 8px;
      transition: background-color 0.2s;
      z-index: 1001;
    }

    .lightbox-nav:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .lightbox-nav.prev {
      left: 1rem;
    }

    .lightbox-nav.next {
      right: 1rem;
    }

    body.lightbox-open .btn-fixed {
      display: none !important;
    }
  </style>
</head>
<body>

  <header>
    <img src="header.png" class="banner" alt="banni√®re"/>
  </header>

  <h1>Mariage Marine et Nicolas</h1>
  <h2>19 juillet 2025</h2>
  <p>N'h√©sitez pas √† nous partager vos photos ou vid√©os<br />afin de nous laisser un souvenir de cette journ√©e si sp√©ciale.</p>
  
  <button class="btn-share-site" onclick="shareSite()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
      <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
    </svg>
    Partager ce site
  </button>

  <button class="btn-fixed" onclick="openMediaSelector()">Partager mon souvenir</button>
  
  <!-- Input simplifi√© pour tous les appareils avec s√©lection multiple -->
  <input id="mediaInput" type="file" accept="image/*,video/*" multiple onchange="handleFiles(this.files)" />

  <div id="popup" class="modal">
    <div class="modal-content">
      <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Souhaitez-vous afficher ce m√©dia dans la galerie ?</p>
      <div class="loader" id="loader"></div>
      <div class="modal-buttons" id="modalButtons">
        <button class="public-btn" onclick="sendMedia(true)">üì¢ Afficher en public</button>
        <button class="private-btn" onclick="sendMedia(false)">üîí Uniquement pour les mari√©s</button>
      </div>
    </div>
  </div>

  <div id="gallery">
    <h2>Galerie des invit√©s</h2>
    <div id="drive-gallery"></div>
  </div>

  <div class="lightbox" id="lightbox" onclick="closeLightbox(event)">
    <div id="lightbox-content"></div>
    <button class="close-btn" onclick="closeLightbox({target:document.getElementById('lightbox')});">&times;</button>
    <button class="download-btn" id="downloadBtn" onclick="downloadMedia()">
      <img src="telecharger-un-fichier.png" alt="T√©l√©charger"/>
    </button>
    <button class="lightbox-nav prev" onclick="navigateGallery(-1)">‚Äπ</button>
    <button class="lightbox-nav next" onclick="navigateGallery(1)">‚Ä∫</button>
  </div>

  <script>
    const folderId = "1J4fn2yvUhe0MEZY6KZtDb_2PJutP7FL7";
    const apiKey = "AIzaSyAKdgvWZ4dX7oS0btyCHtMSS-bgErTtnhY";
    let galleryFiles = [];
    let currentImageIndex = 0;

    async function loadGallery() {
      const endpoint = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+(mimeType+contains+'image/'+or+mimeType+contains+'video/')&key=${apiKey}&fields=files(id,name,mimeType,thumbnailLink,webContentLink)`;
      const res = await fetch(endpoint);
      const data = await res.json();
      const container = document.getElementById("drive-gallery");

      galleryFiles = data.files;
      container.innerHTML = "";
      
      data.files.forEach((file, index) => {
        const thumb = file.thumbnailLink?.replace("=s220", "=s2000") || ""; // CORRECTION 1: Qualit√© am√©lior√©e
        const webLink = file.webContentLink;

        const wrapper = document.createElement("div");
        const element = file.mimeType.includes("video")
          ? document.createElement("video")
          : document.createElement("img");

        if (file.mimeType.includes("video")) {
          element.src = `https://drive.google.com/uc?export=download&id=${file.id}`;
          element.setAttribute("playsinline", "");
          element.setAttribute("muted", "");
          element.setAttribute("preload", "metadata");
          element.setAttribute("poster", thumb);
        } else {
          // CORRECTION 2: Utiliser l'image haute qualit√© pour l'affichage
          element.src = `https://drive.google.com/uc?export=view&id=${file.id}`;
          // Fallback sur thumbnail en cas d'erreur
          element.onerror = function() {
            this.src = thumb;
          };
        }
        
        element.alt = file.name;
        element.setAttribute("data-full", webLink);
        element.onclick = () => openLightbox(file.mimeType, element.src, webLink, index);

        wrapper.appendChild(element);
        container.appendChild(wrapper);
      });
    }

    function openLightbox(type, src, downloadLink, index) {
      currentImageIndex = index;
      const content = document.getElementById("lightbox-content");
      const lightbox = document.getElementById("lightbox");
      const btn = document.getElementById("downloadBtn");

      content.innerHTML = "";

      if (type.includes("video")) {
        // CORRECTION: Utiliser un lecteur vid√©o natif HTML5
        const fileId = galleryFiles[index].id;
        const video = document.createElement("video");
        video.src = `https://drive.google.com/uc?export=download&id=${fileId}`;
        
        // Attributs pour optimiser la lecture vid√©o
        video.controls = true;
        video.setAttribute("playsinline", "");
        video.setAttribute("preload", "metadata");
        video.style.width = "100%";
        video.style.height = "auto";
        video.style.maxWidth = "90vw";
        video.style.maxHeight = "85vh";
        video.style.borderRadius = "8px";
        video.style.backgroundColor = "#000";
        
        // Gestion d'erreur avec fallback
        video.onerror = function() {
          console.error("Erreur de lecture vid√©o, tentative avec URL alternative");
          this.src = `https://drive.google.com/file/d/${fileId}/view`;
        };
        
        content.appendChild(video);
        
      } else {
        const el = document.createElement("img");
        const fileId = galleryFiles[index].id;
        // Image haute qualit√© dans la lightbox
        el.src = `https://drive.google.com/uc?export=view&id=${fileId}`;
        
        // Fallback en cas d'erreur
        el.onerror = function() {
          const thumb = galleryFiles[index].thumbnailLink?.replace("=s220", "=s2000") || "";
          this.src = thumb;
        };
        
        content.appendChild(el);
      }

      btn.setAttribute("data-src", downloadLink);
      document.body.classList.add("lightbox-open");
      lightbox.style.display = "flex";
      
      updateNavigationButtons();
    }

    function navigateGallery(direction) {
      currentImageIndex += direction;
      
      if (currentImageIndex < 0) currentImageIndex = galleryFiles.length - 1;
      if (currentImageIndex >= galleryFiles.length) currentImageIndex = 0;
      
      const file = galleryFiles[currentImageIndex];
      const thumb = file.thumbnailLink?.replace("=s220", "=s600") || "";
      const src = file.mimeType.includes("video")
        ? `https://drive.google.com/uc?export=download&id=${file.id}`
        : thumb;
      
      openLightbox(file.mimeType, src, file.webContentLink, currentImageIndex);
    }

    function updateNavigationButtons() {
      const prevBtn = document.querySelector('.lightbox-nav.prev');
      const nextBtn = document.querySelector('.lightbox-nav.next');
      
      prevBtn.style.display = galleryFiles.length > 1 ? 'block' : 'none';
      nextBtn.style.display = galleryFiles.length > 1 ? 'block' : 'none';
    }

    function downloadMedia() {
      const src = document.getElementById("downloadBtn").getAttribute("data-src");
      
      // Cr√©er un lien de t√©l√©chargement et le d√©clencher
      const a = document.createElement("a");
      a.href = src;
      a.download = galleryFiles[currentImageIndex].name || "media";
      a.target = "_blank";
      
      // Ajouter temporairement le lien au DOM
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    function closeLightbox(event) {
      if (event.target.id === "lightbox" || event.key === "Escape" || event.target.classList.contains('close-btn')) {
        document.getElementById("lightbox").style.display = "none";
        document.body.classList.remove("lightbox-open");
      }
    }

    document.addEventListener("keydown", closeLightbox);
    window.addEventListener("DOMContentLoaded", loadGallery);

    // Fonction simplifi√©e pour ouvrir le s√©lecteur de m√©dia
    function openMediaSelector() {
      // Ouvrir directement l'input sur tous les appareils
      document.getElementById('mediaInput').click();
    }

    // Fonction de partage du site
    async function shareSite() {
      const shareData = {
        title: 'Mariage Marine & Nicolas',
        text: 'Venez partager vos souvenirs du mariage de Marine & Nicolas ! üì∏üíï',
        url: window.location.href
      };

      try {
        // V√©rifier si l'API Web Share est support√©e
        if (navigator.share) {
          await navigator.share(shareData);
        } else {
          // Fallback : copier le lien et afficher un message
          await navigator.clipboard.writeText(window.location.href);
          alert('Lien copi√© dans le presse-papiers !\n\nVous pouvez maintenant le partager via WhatsApp, SMS ou email.');
        }
      } catch (err) {
        // En cas d'erreur ou d'annulation, proposer la copie du lien
        if (err.name !== 'AbortError') {
          try {
            await navigator.clipboard.writeText(window.location.href);
            alert('Lien copi√© dans le presse-papiers !');
          } catch (clipboardErr) {
            // Fallback ultime si m√™me le clipboard ne fonctionne pas
            prompt('Copiez ce lien pour le partager :', window.location.href);
          }
        }
      }
    }

    let selectedFiles = [];
    
    // Fonction pour g√©rer la s√©lection multiple avec aper√ßu (VERSION SIMPLIFI√âE QUI MARCHE)
    function handleFiles(files) {
      if (files && files.length > 0) {
        selectedFiles = Array.from(files);
        
        // V√©rification imm√©diate des tailles SANS compression
        const errors = [];
        let totalSizeMB = 0;
        
        files.forEach(file => {
          const sizeMB = file.size / (1024 * 1024);
          totalSizeMB += sizeMB;
          
          if (file.type.startsWith('video/') && sizeMB > 15) {
            errors.push(`Vid√©o ${file.name} trop volumineuse (${sizeMB.toFixed(1)}MB). Maximum 15MB.`);
          }
          if (file.type.startsWith('image/') && sizeMB > 8) {
            errors.push(`Photo ${file.name} trop volumineuse (${sizeMB.toFixed(1)}MB). Maximum 8MB.`);
          }
        });
        
        if (totalSizeMB > 40) {
          errors.push(`S√©lection totale trop volumineuse (${totalSizeMB.toFixed(1)}MB). Maximum 40MB.`);
        }
        
        if (errors.length > 0) {
          showDiscretError(errors[0]); // Afficher la premi√®re erreur
          return;
        }
        
        // Si OK, afficher l'aper√ßu directement
        showFilePreview(selectedFiles);
      }
    }
    
    // SUPPRESSION de la compression (trop lente et instable)
    // Les fonctions de compression sont supprim√©es
    
    // Fonction de compression intelligente pour images
    async function compressImageIntelligently(file) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
          // Compression intelligente bas√©e sur la taille du fichier
          const fileSizeMB = file.size / (1024 * 1024);
          let shouldCompress = fileSizeMB > 2; // Compresser si > 2MB
          
          if (!shouldCompress) {
            // Fichier d√©j√† optimal, garder l'original
            resolve(file);
            return;
          }
          
          // Calculer les nouvelles dimensions (max 1920px sur le c√¥t√© le plus large)
          const maxDimension = 1920;
          let { width, height } = img;
          
          if (width > maxDimension || height > maxDimension) {
            if (width > height) {
              height = (height * maxDimension) / width;
              width = maxDimension;
            } else {
              width = (width * maxDimension) / height;
              height = maxDimension;
            }
          }
          
          // Redimensionner l'image
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          
          // D√©terminer la qualit√© selon la taille originale
          let quality = 0.8; // 80% par d√©faut
          if (fileSizeMB > 5) quality = 0.75; // 75% pour les tr√®s gros fichiers
          if (fileSizeMB > 10) quality = 0.7; // 70% pour les √©normes fichiers
          
          // Convertir en blob avec compression
          canvas.toBlob((blob) => {
            // Cr√©er un nouveau fichier avec le m√™me nom
            const compressedFile = new File([blob], file.name, {
              type: 'image/jpeg',
              lastModified: Date.now()
            });
            
            console.log(`üì∏ Compression: ${file.name} - ${Math.round(fileSizeMB)}MB ‚Üí ${Math.round(compressedFile.size / 1024 / 1024)}MB`);
            resolve(compressedFile);
          }, 'image/jpeg', quality);
        };
        
        img.onerror = () => {
          // En cas d'erreur, garder le fichier original
          console.warn(`Impossible de compresser ${file.name}, conservation de l'original`);
          resolve(file);
        };
        
        img.src = URL.createObjectURL(file);
      });
    }
    
    // Fonction pour afficher l'aper√ßu des fichiers s√©lectionn√©s (version simplifi√©e)
    function showFilePreview(files) {
      const modalContent = document.querySelector('.modal-content');
      const fileCount = files.length;
      
      // G√©n√©rer l'aper√ßu des fichiers (sans informations techniques)
      let filePreviewHtml = '';
      files.forEach((file, index) => {
        const fileType = file.type.includes('video') ? 'üé•' : 'üì∑';
        const fileName = file.name.length > 18 ? file.name.substring(0, 18) + '...' : file.name;
        filePreviewHtml += `
          <div style="display: flex; align-items: center; padding: 0.6rem; margin: 0.3rem 0; background: #f8f9fa; border-radius: 8px;">
            <span style="font-size: 1.2rem; margin-right: 0.7rem;">${fileType}</span>
            <span style="font-size: 0.95rem; color: #333;">${fileName}</span>
          </div>
        `;
      });
      
      // Texte adapt√© au nombre de fichiers
      const fileTypes = files.map(f => f.type.includes('video') ? 'vid√©o' : 'photo');
      const hasVideos = fileTypes.includes('vid√©o');
      const hasPhotos = fileTypes.includes('photo');
      
      let typeText = '';
      if (hasVideos && hasPhotos) {
        typeText = `${fileCount} m√©dias`;
      } else if (hasVideos) {
        typeText = fileCount === 1 ? '1 vid√©o' : `${fileCount} vid√©os`;
      } else {
        typeText = fileCount === 1 ? '1 photo' : `${fileCount} photos`;
      }
      
      modalContent.innerHTML = `
        <div style="padding: 1.5rem;">
          <h3 style="margin-bottom: 1rem; color: #333;">Envoyer ${typeText} ?</h3>
          <div style="max-height: 220px; overflow-y: auto; margin-bottom: 1.5rem;">
            ${filePreviewHtml}
          </div>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 1.5rem;">
            ${fileCount === 1 ? 'Ce fichier sera' : 'Ces fichiers seront'} ajout√©s √† la galerie publique.
          </p>
          <div style="display: flex; flex-direction: column; gap: 1rem;">
            <button onclick="confirmUpload(true)" style="
              background-color: #818edb; color: white; border: none; padding: 1rem 1.5rem; 
              border-radius: 12px; font-weight: bold; cursor: pointer; font-size: 1rem;
              transition: all 0.2s;
            " onmouseover="this.style.backgroundColor='#6f7ac7'" onmouseout="this.style.backgroundColor='#818edb'">
              üì¢ Envoyer ${typeText}
            </button>
            <button onclick="cancelUpload()" style="
              background-color: #f0f0f0; color: #666; border: none; padding: 0.8rem 1.5rem; 
              border-radius: 12px; cursor: pointer; font-size: 0.9rem;
            " onmouseover="this.style.backgroundColor='#e0e0e0'" onmouseout="this.style.backgroundColor='#f0f0f0'">
              Annuler
            </button>
          </div>
        </div>
      `;
      
      // Afficher la modal
      document.getElementById('popup').style.display = 'flex';
    }
    
    // Fonction pour confirmer l'upload (SANS contraintes artificielles)
    function confirmUpload(isPublic) {
      const modalContent = document.querySelector('.modal-content');
      const fileCount = selectedFiles.length;
      
      // LOG: Afficher les tailles des fichiers pour debug
      console.log('üîç ANALYSE DES FICHIERS:');
      selectedFiles.forEach((file, index) => {
        const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
        console.log(`üìÅ Fichier ${index + 1}: ${file.name} - ${sizeMB}MB - Type: ${file.type}`);
      });
      
      const totalSizeMB = selectedFiles.reduce((total, file) => total + file.size, 0) / (1024 * 1024);
      console.log(`üì¶ TAILLE TOTALE: ${totalSizeMB.toFixed(2)}MB`);
      
      // Feedback imm√©diat de succ√®s (AUCUNE LIMITE ARTIFICIELLE)
      modalContent.innerHTML = `
        <div style="padding: 2rem;">
          <div style="font-size: 3rem; margin-bottom: 1rem;">üéâ</div>
          <h3 style="color: #4CAF50; margin-bottom: 1rem;">Merci !</h3>
          <p style="font-size: 1.1rem;">
            ${fileCount === 1 ? 'Votre fichier a √©t√© re√ßu' : `Vos ${fileCount} fichiers ont √©t√© re√ßus`} ! 
            ${fileCount === 1 ? 'Il' : 'Ils'} seront trait√©s dans quelques instants.
          </p>
          <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
            Vous pouvez continuer √† utiliser le site normalement.
          </p>
        </div>
      `;
      
      // Fermer automatiquement apr√®s 3 secondes
      setTimeout(() => {
        document.getElementById('popup').style.display = 'none';
        resetModal();
      }, 3000);
      
      // Upload en arri√®re-plan
      uploadMultipleFilesInBackground(selectedFiles, isPublic);
      
      // R√©initialiser la s√©lection
      selectedFiles = [];
      document.getElementById('mediaInput').value = '';
    }
    
    // Fonction pour annuler l'upload
    function cancelUpload() {
      document.getElementById('popup').style.display = 'none';
      resetModal();
      
      // R√©initialiser la s√©lection
      selectedFiles = [];
      document.getElementById('mediaInput').value = '';
    }
    
    // Fonction pour r√©initialiser la modal
    function resetModal() {
      const modalContent = document.querySelector('.modal-content');
      modalContent.innerHTML = `
        <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">Souhaitez-vous afficher ce m√©dia dans la galerie ?</p>
        <div class="loader" id="loader"></div>
        <div class="modal-buttons" id="modalButtons">
          <button class="public-btn" onclick="sendMedia(true)">üì¢ Afficher en public</button>
          <button class="private-btn" onclick="sendMedia(false)">üîí Uniquement pour les mari√©s</button>
        </div>
      `;
    }
    
    // Fonction de compatibilit√© pour l'upload simple
    function handleFile(file) {
      if (file) {
        handleFiles([file]);
      }
    }

    // Variables pour la gestion de la charge
    let uploadQueue = [];
    let activeUploads = 0;
    const MAX_CONCURRENT_UPLOADS = 3; // Limitation pour √©viter la surcharge
    const MAX_RETRY_ATTEMPTS = 3;

    // Fonction pour uploader plusieurs fichiers avec gestion de charge am√©lior√©e
    async function uploadMultipleFilesInBackground(files, isPublic) {
      console.log(`üöÄ Ajout de ${files.length} fichier(s) √† la queue d'upload`);
      
      // CORRECTION: La v√©rification de limite est maintenant dans confirmUpload()
      // Cette fonction ne re√ßoit que des fichiers valid√©s
      
      // Ajouter les fichiers √† la queue
      files.forEach(file => {
        uploadQueue.push({
          file: file,
          isPublic: isPublic,
          attempts: 0,
          id: Date.now() + Math.random() // ID unique
        });
      });
      
      // D√©marrer le traitement de la queue
      processUploadQueue();
    }
    
    // Fonction pour traiter la queue d'upload
    async function processUploadQueue() {
      while (uploadQueue.length > 0 && activeUploads < MAX_CONCURRENT_UPLOADS) {
        const uploadTask = uploadQueue.shift();
        if (uploadTask) {
          activeUploads++;
          uploadFileWithRetry(uploadTask).finally(() => {
            activeUploads--;
            // Continuer le traitement de la queue
            if (uploadQueue.length > 0) {
              setTimeout(() => processUploadQueue(), 200); // Petite pause entre uploads
            } else if (activeUploads === 0) {
              // Tous les uploads termin√©s
              console.log('‚úÖ Tous les uploads termin√©s');
              setTimeout(() => loadGallery(), 1500); // Recharger la galerie
            }
          });
        }
      }
    }
    
    // Fonction d'upload avec retry automatique
    async function uploadFileWithRetry(uploadTask) {
      const { file, isPublic, attempts, id } = uploadTask;
      
      try {
        console.log(`üì§ Upload ${file.name} (tentative ${attempts + 1}/${MAX_RETRY_ATTEMPTS})`);
        await uploadSingleFileInBackground(file, isPublic);
        console.log(`‚úÖ Upload r√©ussi: ${file.name}`);
        
      } catch (error) {
        console.error(`‚ùå √âchec upload ${file.name}:`, error);
        
        // Retry automatique si pas trop de tentatives
        if (attempts < MAX_RETRY_ATTEMPTS - 1) {
          console.log(`üîÑ Retry ${file.name} dans 2 secondes...`);
          uploadTask.attempts++;
          
          // Remettre en queue avec d√©lai
          setTimeout(() => {
            uploadQueue.unshift(uploadTask); // Priorit√© aux retry
            processUploadQueue();
          }, 2000 + (attempts * 1000)); // D√©lai croissant
          
        } else {
          // √âchec d√©finitif apr√®s tous les retry
          showDiscretError(`√âchec d√©finitif: ${file.name}`);
        }
      }
    }
    
    // Apps Script URL (votre nouveau d√©ploiement)
    const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzdqbRE2_zf_SoyPV0zhST4gwkRZn9nB61r5Umm0xaXQ2kB_GH_hIlb-RVV9FaZ2rQv/exec';

    // FONCTION: Upload resumable depuis Vercel
    async function uploadSingleFileInBackground(file, isPublic) {
      try {
        const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
        console.log(`üöÄ D√©but upload resumable: ${file.name} (${fileSizeMB}MB)`);
        
        // 1. Obtenir le token OAuth via fetch
        const tokenResponse = await fetch(`${APPS_SCRIPT_URL}?action=getToken`);
        if (!tokenResponse.ok) {
          throw new Error('Impossible d\'obtenir le token');
        }
        const tokenData = await tokenResponse.text();
        const token = tokenData.replace(/"/g, ''); // Nettoyer les guillemets
        console.log(`üîë Token OAuth obtenu`);
        
        // 2. Obtenir l'ID du dossier via fetch
        const folderResponse = await fetch(`${APPS_SCRIPT_URL}?action=getFolder&isPublic=${isPublic}`);
        if (!folderResponse.ok) {
          throw new Error('Impossible d\'obtenir le dossier');
        }
        const folderId = (await folderResponse.text()).replace(/"/g, '');
        console.log(`üìÅ Dossier cible: ${folderId}`);
        
        // 3. Initier la session resumable upload
        const metadata = {
          name: file.name,
          parents: [folderId],
          mimeType: file.type
        };
        
        const initResponse = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(metadata)
        });
        
        if (!initResponse.ok) {
          throw new Error(`Erreur initialisation upload: ${initResponse.status}`);
        }
        
        const uploadUrl = initResponse.headers.get('location');
        console.log(`üì° Session upload cr√©√©e`);
        
        // 4. Upload par chunks de 8MB
        const chunkSize = 8 * 1024 * 1024; // 8MB par chunk
        const totalChunks = Math.ceil(file.size / chunkSize);
        
        for (let i = 0; i < totalChunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const chunk = file.slice(start, end);
          
          console.log(`üì¶ Upload chunk ${i + 1}/${totalChunks} (${(start/1024/1024).toFixed(1)}-${(end/1024/1024).toFixed(1)}MB)`);
          
          const chunkResponse = await fetch(uploadUrl, {
            method: 'PUT',
            headers: {
              'Content-Range': `bytes ${start}-${end-1}/${file.size}`,
              'Content-Length': chunk.size.toString()
            },
            body: chunk
          });
          
          // 308 = Continue, 200/201 = Fini
          if (chunkResponse.status !== 308 && !chunkResponse.ok) {
            throw new Error(`Erreur chunk ${i + 1}: ${chunkResponse.status}`);
          }
          
          if (chunkResponse.ok && chunkResponse.status !== 308) {
            console.log(`‚úÖ Upload termin√©: ${file.name}`);
            break;
          }
        }
        
        console.log(`üéâ SUCC√àS: ${file.name} upload√© avec resumable upload`);
        return true;
        
      } catch (error) {
        console.error(`‚ùå Erreur upload resumable:`, error);
        throw error;
      }
    }

    // Fonction pour afficher une erreur discr√®te
    function showDiscretError(message) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #f44336;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 25px;
        font-size: 0.9rem;
        z-index: 1001;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      // Animation d'apparition
      setTimeout(() => notification.style.opacity = '1', 100);
      
      // Supprimer apr√®s 4 secondes
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 4000);
    }

    async function sendMedia(isPublic) {
      // Cette fonction n'est plus utilis√©e car le feedback est imm√©diat dans handleFiles()
      console.log('sendMedia appel√©e, mais upload d√©j√† fait en arri√®re-plan');
    }

    // Fonction de compatibilit√© pour l'upload simple
    async function uploadFileInBackground(file, isPublic) {
      return uploadSingleFileInBackground(file, isPublic);
    }
  </script>

</body>
</html>
